# Exploring Kubernetes from within Kubernetes... with Python - PART 2

Part 1 is available [here](2022-04-10.md)

Part 1 was a "set the scene" kind of post and in the post I will explore the actual Python solution to gather some basic statistics from within the cluster.

Once again, keep in mind that this is not a "how to measure resources" blog post - there are far better tools for that. This is a way to understand the Python Kubernetes Client at the hand of a practical example.

## The goal

The goal for this post is a Python application with a REST API that will print the available CPU and Memory per Node as well as the committed CPU and Memory per Node.

The output data will be in JSON with the following basic structure (example output, showing 1 node only):

```json
{
    "Nodes": [
        {
            "NodeName": "node3",
            "CPU": {
                "Capacity": 2000,
                "Allocatable": 2000,
                "Requests": {
                    "InstrumentedValue": 750.0,
                    "Percent": 37.5
                },
                "Limits": {
                    "InstrumentedValue": 1500.0,
                    "Percent": 75.0
                }
            },
            "RAM": {
                "Capacity": 8344227840,
                "Allocatable": 8344227840,
                "Requests": {
                    "InstrumentedValue": 530579456.0,
                    "Percent": 6.358640561761075
                },
                "Limits": {
                    "InstrumentedValue": 1073741824.0,
                    "Percent": 12.868078923405813
                }
            }
        }
    ]
}
```

# Project Implementation

The Python code can be found on GitHub, is the (probably) funny names [pykles repository](https://github.com/nicc777/pykles).

The container is also already available on [Docker Hub](https://hub.docker.com/r/nicc777/pykles)

The focus of this blog post in the Kubernetes CLient implementation and perhaps I will do another blog post (or two) about the rest of the stack, like FastAPI.

In Part 1 I discussed the background and I also refer to my K3s Kubernetes cluster as described in an even earlier [blog post](2022-04-03.md).

## Deployment

To deploy the application, simply run the following:

```shell
kubectl create namespace pykles

kubectl apply -f https://raw.githubusercontent.com/nicc777/pykles/main/kubernetes_manifests/pykles.yaml -n pykles
```

Once deployed, your resources should look something like this:

```text
NAME                                     READY   STATUS    RESTARTS   AGE
pod/pykles-deployment-7944474c57-phw2t   1/1     Running   0          50s

NAME                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
service/pykles-app-service   ClusterIP   10.43.122.237   <none>        8080/TCP   50s

NAME                                READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/pykles-deployment   1/1     1            1           50s

NAME                                           DESIRED   CURRENT   READY   AGE
replicaset.apps/pykles-deployment-7944474c57   1         1         1       50s
```

But in order to test, we need to connect to the REST API. To simplify this process, the following command illustrate how to use the `kubectl` port forwarder:

```shell
kubectl port-forward pod/pykles-deployment-7944474c57-phw2t -n pykles 7081:8080
```

_**Note**_: Ensure you refer to the correct POD!

## Simple Testing of the REST end-point

We can now use `curl` to test:

```shell
curl http://localhost:7081/
```

Your output should look something like this:

```json
{"Nodes":[{"NodeName":"node1","CPU":{"Capacity":2000,"Allocatable":2000,"Requests":{"InstrumentedValue":0.0,"Percent":0.0},"Limits":{"InstrumentedValue":0.0,"Percent":0.0}},"RAM":{"Capacity":8344227840,"Allocatable":8344227840,"Requests":{"InstrumentedValue":73400320.0,"Percent":0.8796538326546942},"Limits":{"InstrumentedValue":178257920.0,"Percent":2.136302165018543}}},{"NodeName":"node2","CPU":{"Capacity":2000,"Allocatable":2000,"Requests":{"InstrumentedValue":500.0,"Percent":25.0},"Limits":{"InstrumentedValue":1000.0,"Percent":50.0}},"RAM":{"Capacity":8344227840,"Allocatable":8344227840,"Requests":{"InstrumentedValue":268435456.0,"Percent":3.217019730851453},"Limits":{"InstrumentedValue":536870912.0,"Percent":6.434039461702906}}},{"NodeName":"node3","CPU":{"Capacity":2000,"Allocatable":2000,"Requests":{"InstrumentedValue":750.0,"Percent":37.5},"Limits":{"InstrumentedValue":1500.0,"Percent":75.0}},"RAM":{"Capacity":8344227840,"Allocatable":8344227840,"Requests":{"InstrumentedValue":530579456.0,"Percent":6.358640561761075},"Limits":{"InstrumentedValue":1073741824.0,"Percent":12.868078923405813}}}]}
```

If you followed the instructions from the previous blog posts, you should now have statistics of three nodes.



